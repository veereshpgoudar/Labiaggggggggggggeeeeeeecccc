<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab programs</title>
    <style>
            body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    height: 100vh;
    overflow: hidden;
    background: linear-gradient(45deg, rgba(255, 0, 150, 0.7), rgba(0, 204, 255, 0.7), rgba(0, 255, 255, 0.7));
    background-size: 400% 400%;
    animation: gradientAnimation 2s ease infinite;
    display: flex;
    justify-content: center;
    align-items: center;
}

@keyframes gradientAnimation {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
}

#output {
    font-family: 'Times New Roman', Times, serif;
    font-size: 16px;
    color: black;
    white-space: pre-wrap; /* Preserve whitespace */
    overflow-y: auto; /* Enable vertical scrolling */
    max-height: 300px; /* Set a maximum height */
    padding: 10px;
    background-color: #f1f1f1;
    border: 1px solid #ccc;
    border-radius: 5px;
    display: inline-block;
    animation: caret-blink 0.7s steps(1) infinite, slideIn 1s ease-out;
}

/* Optional caret-blink animation */
@keyframes caret-blink {
    0% {
        border-right-color: transparent;
    }
    50% {
        border-right-color: black;
    }
    100% {
        border-right-color: transparent;
    }
}

/* Slide-in animation for #output */
@keyframes slideIn {
    0% {
        transform: translateX(100%);
    }
    100% {
        transform: translateX(0);
    }
}

.container {
    background-color: white;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    width: 100%;
    max-width: 1200px;
    margin: 0 auto; 
    z-index: 1;
    opacity: 0;
    animation: fadeIn 2s forwards, bounceIn 1s ease-out;
}

/* Text fade-in animation */
@keyframes fadeIn {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Bounce effect for container */
@keyframes bounceIn {
    0% {
        transform: scale(0);
    }
    50% {
        transform: scale(1.2);
    }
    100% {
        transform: scale(1);
    }
}

h1 {
    text-align: center;
    color: #333;
    font-size: 24px;
    animation: slideIn 2s ease-out, fadeInText 1.5s ease-out;
}

/* Animation for heading */
@keyframes slideIn {
    0% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(0);
    }
}

/* Text fade-in effect for heading */
@keyframes fadeInText {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

.form-group {
    margin-bottom: 15px;
    animation: fadeIn 2s ease-out, scaleUp 1s ease-in-out;
}

/* Scale-up effect for form group */
@keyframes scaleUp {
    0% {
        transform: scale(0.8);
    }
    100% {
        transform: scale(1);
    }
}

label {
    display: block;
    font-weight: bold;
    margin-bottom: 5px;
}

select {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    border-radius: 4px;
    border: 1px solid #ccc;
    opacity: 0;
    animation: fadeIn 2s ease-out forwards, slideUp 1.5s ease-out;
}

/* Slide-up effect for select */
@keyframes slideUp {
    0% {
        transform: translateY(30px);
        opacity: 0;
    }
    100% {
        transform: translateY(0);
        opacity: 1;
    }
}

.output {
    margin-top: 20px;
    visibility: hidden; /* Hide initially */
}

.program-output {
    background-color: #f1f1f1;
    padding: 10px;
    border-radius: 5px;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 300px;
    overflow-y: auto;
    animation: fadeIn 1s ease-out forwards, liquidText 3s ease-in-out infinite;
    font-size: 16px;
    color: #333;
    position: relative;
    z-index: 0;
}

/* Liquid text animation */
@keyframes liquidText {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-5px);
    }
}

@keyframes shake {
    0% {
        transform: translateX(-10px);
    }
    25% {
        transform: translateX(10px);
    }
    50% {
        transform: translateX(-10px);
    }
    75% {
        transform: translateX(10px);
    }
    100% {
        transform: translateX(0);
    }
}

.programs-list {
    animation: shake 0.5s ease-in-out, spin 1.5s ease-in-out infinite;
}

/* Spin animation for .programs-list */
@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}
        

    </style>
</head>
<body>
    <div class="container">
        <h1>VTU Lab Programs</h1>
        <div class="form-group">
            <label for="semester">Select Semester:</label>
            <select id="semester" onchange="updatePrograms()"/>
                <option value="">--Select Semester--</option>
                <option value="sem1">Semester 1</option>
                <option value="sem2">Semester 2</option>
                <option value="sem3">Semester 3</option>
                <option value="sem4">Semester 4</option>
            </select>
        </div>
        <div class="form-group">
            <label for="subject">Select Subject:</label>
            <select id="subject" onchange="updatePrograms()">
                <option value="">--Select Subject--</option>
                <option value="oop">Object-Oriented Programming (Java)</option>
                <option value="os">Operating System</option>
                <option value="ds">Data Structures</option>
                <option value="python">Python Programming</option>
            </select>
        </div>
        <div class="form-group">
            <label for="program">Select Program:</label>
            <select id="program">
                <option value="">--Select Program--</option>
            </select>
        </div>
        <div class="output">
            <h3>Program Output:</h3>
            <pre id="output" class="program-output"></pre>
        </div>
    </div>

    <script>
        const programsData = {
            sem1: {
                oop: [
                    "NOT UPDATE"
                ],
                os: [
                    "NOT UPDATE"
                ],
                ds: [
                    "NOT UPDATE"
                ],
                python: [
                    "NOT UPDATE"
                ]
            },
            sem2: {
                oop: [
                    "NOT UPDATE"
                ],
                os: [
                    "NOT UPDATE"
                ],
                ds: [
                    "NOT UPDATE"
                ],
                python: [
                    "NOT UPDATE"
                ]
            },
            sem3: {
                oop: [
                   `Program 1: 

/*Java Program to add two matrix*/
import java.util.Scanner;

public class MatrixAdd {
    public static void main(String[] args) {
        int p, q, m, n; // Declare matrix size
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of rows in the first matrix:");
        p = sc.nextInt(); // Initialize first matrix size
        System.out.print("Enter the number of columns in the first matrix:");
        q = sc.nextInt(); // Initialize first matrix size
        System.out.print("Enter the number of rows in the second matrix:");
        m = sc.nextInt(); // Initialize second matrix size
        System.out.print("Enter the number of columns in the second matrix:");
        n = sc.nextInt(); // Initialize second matrix size
        if (p == m && q == n) {
            int a[][] = new int[p][q]; // Declare first matrix
            int b[][] = new int[m][n]; // Declare second matrix
            int c[][] = new int[m][n]; // Declare third matrix
            // Initialize the first matrix
            System.out.println("Enter all the elements of first matrix:");
            for (int i = 0; i < p; i++) {
                for (int j = 0; j < q; j++) {
                    a[i][j] = sc.nextInt();
                }
            }
            System.out.println(" ");
            // Initialize the second matrix
            System.out.println("Enter all the elements of second matrix:");
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    b[i][j] = sc.nextInt();
                }
            }
            System.out.println(" ");
            // Print the first matrix
            System.out.println("First Matrix:");
            for (int i = 0; i < p; i++) {
                for (int j = 0; j < q; j++) {
                    System.out.print(a[i][j] + " ");
                }
                System.out.println(" ");
            }
            // Print the second matrix
            System.out.println("Second Matrix:");
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    System.out.print(b[i][j] + " ");
                }
                System.out.println(" ");
            }
            // Loop to add matrix elements
            for (int i = 0; i < p; i++) {
                for (int j = 0; j < n; j++) {
                    for (int k = 0; k < q; k++) {
                        c[i][j] = a[i][j] + b[i][j];
                    }
                }
            }
            // Print the resultant matrix
            System.out.println("Matrix after addition:");
            for (int i = 0; i < p; i++) {
                for (int j = 0; j < n; j++) {
                    System.out.print(c[i][j] + " ");
                }
                System.out.println(" ");
            }
        } else {
            System.out.println("Addition not possible");
            System.out.println("Try Again");
        }
    }
}`,



`Program 2: 

class Stack {
    private int arr[];
    private int top;
    private int capacity;

    // Constructor to initialize the stack
    Stack(int size) {
        arr = new int[size];
        capacity = size;
        top = -1;
    }

    // Utility function to add an element to the stack
    public void push(int x) {
        if (isFull()) {
            System.out.println("Overflow\nProgram Terminated\n");
            System.exit(-1);
        }
        System.out.println("Inserting " + x);
        arr[++top] = x;
    }

    // Utility function to pop a top element from the stack
    public int pop() {
        // check for stack underflow
        if (isEmpty()) {
            System.out.println("Underflow\nProgram Terminated");
            System.exit(-1);
        }
        System.out.println("Removing " + peek());
        // decrease stack size by 1 and (optionally) return the popped element
        return arr[top--];
    }

    // Utility function to return the top element of the stack
    public int peek() {
        if (!isEmpty()) {
            return arr[top];
        } else {
            System.exit(-1);
        }
        return -1;
    }

    // Utility function to return the size of the stack
    public int size() {
        return top + 1;
    }

    // Utility function to check if the stack is empty or not
    public boolean isEmpty() {
        return top == -1; // or return size() == 0;
    }

    // Utility function to check if the stack is full or not
    public boolean isFull() {
        return top == capacity - 1; // or return size() == capacity;
    }
}

class StackArrayV2 {
    public static void main(String[] args) {
        Stack stack = new Stack(3);
        stack.push(1); // inserting 1 in the stack
        stack.push(2); // inserting 2 in the stack
        stack.pop(); // removing the top element (2)
        stack.pop(); // removing the top element (1)
        stack.push(3); // inserting 3 in the stack
        System.out.println("The top element is " + stack.peek());
        System.out.println("The stack size is " + stack.size());
        stack.pop(); // removing the top element (3)
        // check if the stack is empty
        if (stack.isEmpty()) {
            System.out.println("The stack is empty");
        } else {
            System.out.println("The stack is not empty");
        }
    }
}`,


`Program 3:

class Employee {
    int id;
    String firstname;
    String lastname;
    int salary;

    Employee(int id1, String firstname1, String lastname1, int salary1) {
        id = id1;
        firstname = firstname1;
        lastname = lastname1;
        salary = salary1;
    }

    int getId() {
        return id;
    }

    String getFirstName() {
        return firstname;
    }

    String getName() {
        return firstname + " " + lastname;
    }

    int getAnnualSalary() {
        return 12 * salary;
    }

    int raiseSalary(int r) {
        int raise = salary / 100 * r;
        System.out.print("raise in salary is:" + " ");
        return salary + raise;
    }

    void setSalary(int sal) {
        salary = sal;
    }

    String getLastName() {
        return lastname;
    }

    int getSalary() {
        return salary;
    }

    public String toString() {
        return "object";
    }
}

public class EmployeeDetails {
    public static void main(String[] args) {
        // Test constructor and toString()
        Employee e1 = new Employee(8, "Shivaprakash", "Tumbagi", 2500);
        System.out.println(e1); // toString();
        // Test Setters and Getters
        e1.setSalary(999);
        System.out.println("id is: " + e1.getId());
        System.out.println("firstname is: " + e1.getFirstName());
        System.out.println("lastname is: " + e1.getLastName());
        System.out.println("salary is: " + e1.getSalary());
        System.out.println("name is: " + e1.getName());
        System.out.println("annual salary is: " + e1.getAnnualSalary()); // Test method
        System.out.println(e1.raiseSalary(10));
        System.out.println(e1);
    }
}`,

`Program 4: 

class Mypoint {
    int x, y;

    Mypoint() {
        x = 0;
        y = 0;
    }

    Mypoint(int a, int b) {
        x = a;
        y = b;
    }

    int getX() {
        return x;
    }

    int getY() {
        return y;
    }

    void setX(int c) {
        x = c;
    }

    void setY(int d) {
        y = d;
    }

    void setXY(int f, int g) {
        x = f;
        y = g;
    }

    int[] getXY() {
        int arr[] = new int[2];
        arr[0] = x;
        arr[1] = y;
        return arr;
    }

    double distance(int x, int y) {
        int xdiff = this.x - x;
        int ydiff = this.y - y;
        System.out.print("Distance (two arguments)=");
        return Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }

    double distance(Mypoint my) {
        int xdiff = this.x - my.x;
        int ydiff = this.y - my.y;
        System.out.print("Distance (Object passed)=");
        return Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }

    double distance() {
        int xdiff = this.x - 0;
        int ydiff = this.y - 0;
        System.out.print("Distance (no arguments passed)=");
        return Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
}

public class MypointTest {
    public static void main(String[] args) {
        Mypoint p1 = new Mypoint(); // Test constructor
        System.out.println(p1); // Test toString()
        p1.setX(8); // Test setters
        p1.setY(6);
        System.out.println("x is: " + p1.getX()); // Test getters
        System.out.println("y is: " + p1.getY());
        p1.setXY(3, 0); // Test setXY()
        System.out.println("x and y after setting new values");
        System.out.println("x is: " + p1.getX()); // Test getters
        System.out.println("y is: " + p1.getY());
        System.out.println("Displaying x and y using getXY method");
        System.out.println(p1.getXY()[0]); // Test getXY()
        System.out.println(p1.getXY()[1]);
        System.out.println(p1);
        Mypoint p2 = new Mypoint(0, 4); // Test another constructor
        System.out.println(p2);
        System.out.println("x is: " + p2.getX()); // Test getters
        System.out.println("y is: " + p2.getY());
        // Testing the overloaded methods distance()
        System.out.println(p1.distance(p2)); // which version?
        System.out.println(p2.distance(p1)); // which version?
        System.out.println(p1.distance(5, 6)); // which version?
        System.out.println(p1.distance()); // which version?
    }
}`,


`Program 5:  

class Shape1 {
    void draw() {
        System.out.println("Drawing Shape");
    }

    void erase() {
        System.out.println("erasing Shape");
    }
}

class Circle1 extends Shape1 {
    void draw() {
        System.out.println("Drawing Circle");
    }

    void erase() {
        System.out.println("erasing Circle");
    }
}

class Triangle1 extends Shape1 {
    void draw() {
        System.out.println("Drawing Triangle");
    }

    void erase() {
        System.out.println("erasing Triangle");
    }
}

class Square1 extends Shape1 {
    void draw() {
        System.out.println("Drawing Square");
    }

    void erase() {
        System.out.println("erasing Square");
    }
}

class ShapeDE {
    public static void main(String args[]) {
        Shape1 c = new Circle1();
        Shape1 t = new Triangle1();
        Shape1 s = new Square1();
        c.draw();
        c.erase();
        t.draw();
        t.erase();
        s.draw();
        s.erase();
    }
}`,



`Program 6:

// Base class Shape
abstract class Shape {
    public abstract double getArea();

    public abstract double getPerimeter();
}

// Subclass Circle
class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}

// Subclass Rectangle
class Rectangle extends Shape {
    private double length;
    private double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    public double getArea() {
        return length * width;
    }

    @Override
    public double getPerimeter() {
        return 2 * (length + width);
    }
}

// Subclass Triangle
class Triangle extends Shape {
    private double side1;
    private double side2;
    private double side3;

    public Triangle(double side1, double side2, double side3) {
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }

    @Override
    public double getArea() {
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    @Override
    public double getPerimeter() {
        return side1 + side2 + side3;
    }
}

public class ShapeT {
    public static void main(String[] args) {
        double r = 4.0;
        Circle circle = new Circle(r);
        double rs1 = 4.0, rs2 = 6.0;
        double ts1 = 3.0, ts2 = 4.0, ts3 = 5.0;
        Rectangle rectangle = new Rectangle(rs1, rs2);
        Triangle triangle = new Triangle(ts1, ts2, ts3);
        System.out.println("Radius of the Circle" + r);
        System.out.println("Area of the Circle: " + circle.getArea());
        System.out.println("Perimeter of the Circle: " + circle.getPerimeter());
        System.out.println("\nSides of the rectangle are: " + rs1 + ',' + rs2);
        System.out.println("Area of the Rectangle: " + rectangle.getArea());
        System.out.println("Perimeter of the Rectangle: " + rectangle.getPerimeter());
        System.out.println("\nSides of the Traiangel are: " + ts1 + ',' + ts2 + ',' + ts3);
        System.out.println("Area of the Triangle: " + triangle.getArea());
        System.out.println("Perimeter of the Triangle: " + triangle.getPerimeter());
    }
}`,


`Program 7:

interface Resizable {
    void resizeWidth(int width);

    void resizeHeight(int height);
}

class Rectangle2 implements Resizable {
    private int width;
    private int height;

    public Rectangle2(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public void resizeWidth(int width) {
        this.width = width;
    }

    public void resizeHeight(int height) {
        this.height = height;
    }

    public void printSize() {
        System.out.println("Width: " + width + ", Height: " + height);
    }
}

public class InterResizable {
    public static void main(String[] args) {
        Rectangle2 rectangle = new Rectangle2(100, 150);
        rectangle.printSize();
        rectangle.resizeWidth(150);
        rectangle.resizeHeight(200);
        rectangle.printSize();
    }
}`,





`Program 8:   

class Outer {
    String so = ("This is Outer Class");

    void display() {
        System.out.println(so);
    }

    void test() {
        Inner inner = new Inner();
        inner.display();
    }

    // this is an inner class
    class Inner {
        String si = ("This is inner Class");

        void display() {
            System.out.println(si);
        }
    }
}

class InnerClassDemo {
    public static void main(String args[]) {
        Outer outer = new Outer();
        outer.display();
        outer.test();
    }
}`,


`Program 9:

import java.io.*;
class ExceptionTest {
public static void main(String[ ] args) {
try {
int number[ ] = new int[10];
number[10] = 30 / 0;
} catch (ArithmeticException e) {
System.out.println(
"Zero cannot divide any number");
} catch (ArrayIndexOutOfBoundsException e) {
System.out.println(
"Index out of size of the array");
}
}
}`,

`Program 10:

//Save Circle1.java
package mypack;
public class Circle1
{
double r;
public void area(int r)
{
System.out.println("Area of the circle = " + (3.14 * r * r));
}
}
//Save Square1.java
package mypack;
public class Square1
{
double s;
public void area(int s)
{
System.out.println("Area of the Square = " + (s * s));
}
}
//Save Rectangle1.java
package mypack;
public class Rectangle1
{
double l,b;
public void area(int l,int b)
{
System.out.println("Area of the circle = " + (l * b));
}
}
//Save PackageTest.java
import mypack. Circle1;
import mypack.Square1;
import mypack.Rectangle1;
class PackageTest
{
public static void main(String a [ ])
{
Circle1 c = new Circle1( );
c.area(10);
Square1 s=new Square1( );
s.area(10);
Rectangle1 r=new Rectangle1( );
r.area(10,10);
}
}`,

`Program 11:

class NewThread implements Runnable {
    Thread t;

    NewThread() {
        // Create a new, second thread
        t = new Thread(this, "Demo Thread");
        System.out.println("Child thread: " + t);
        t.start(); // Start the thread
    }

    // This is the entry point for the second thread.
    public void run() {
        try {
            for (int i = 5; i > 0; i--) {
                System.out.println("Child Thread: " + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println("Child interrupted.");
        }
        System.out.println("Exiting child thread.");
    }
}

class IntThread {
    public static void main(String args[]) {
        new NewThread(); // create a new thread
        try {
            for (int i = 5; i > 0; i--) {
                System.out.println("Main Thread: " + i);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted.");
        }
    }
}`,


`Program 12:
class MyThread extends Thread {
    MyThread() {
        super("using Thread class");
        System.out.println("child thread: " + this);
        start();
    }

    public void run() {
        try {
            for (int i = 5; i > 0; i--) {
                System.out.println("Child thread" + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
        }
        System.out.println("exiting child thread ...");
    }
}

class TestMyThread {
    public static void main(String args[]) {
        new MyThread();
        try {
            for (int k = 5; k < 0; k--) {
                System.out.println("Running main thread:" + k);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
        }
        System.out.println("Exiting main thread...");
    }
}`
],

                os: [
                
                `Program 1: Develop a c program to implement the Process system calls (fork (), exec(), 
wait(), create process, terminate process) :
                    
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid, child_pid;
    int status;

    pid = fork();

    if (pid < 0) {

        perror("fork failed");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {

        printf("Child process: PID = %d, PPID = %d\n", getpid(), getppid());

        execlp("ls", "ls", NULL);

        perror("execlp failed");
        exit(EXIT_FAILURE);
    } else {

        printf("Parent process: PID = %d, Child PID = %d\n", getpid(), pid);

        child_pid = wait(&status);

        if (child_pid == -1) {
            perror("wait failed");
            exit(EXIT_FAILURE);
        }

        if (WIFEXITED(status)) {
            printf("Child process exited with status %d\n", WEXITSTATUS(status));
        } else {
            printf("Child process did not exit normally\n");
        }
    }

    return 0;
}`,
                
                `Program 2: Simulate the following CPU scheduling algorithms to find turnaround 
time and waiting time 
a) FCFS b) SJF c) Round Robin d) Priority.:
                        
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int id;
    int burst_time;
    int priority;
} Process;

void fcfs_scheduling(int n, int burst_times[]) {
    int waiting_time[n], turnaround_time[n];
    waiting_time[0] = 0;
    turnaround_time[0] = burst_times[0];

    for (int i = 1; i < n; i++) {
        waiting_time[i] = waiting_time[i - 1] + burst_times[i - 1];
        turnaround_time[i] = waiting_time[i] + burst_times[i];
    }

    printf("FCFS Scheduling\n");
    printf("Process ID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t\t%d\t\t%d\t\t%d\n", i + 1, burst_times[i], waiting_time[i], turnaround_time[i]);
    }
}

int compare_sjf(const void *a, const void *b) {
    return ((Process *)a)->burst_time - ((Process *)b)->burst_time;
}

void sjf_scheduling(int n, Process processes[]) {
    int waiting_time[n], turnaround_time[n];

    qsort(processes, n, sizeof(Process), compare_sjf);

    waiting_time[0] = 0;
    turnaround_time[0] = processes[0].burst_time;

    for (int i = 1; i < n; i++) {
        waiting_time[i] = waiting_time[i - 1] + processes[i - 1].burst_time;
        turnaround_time[i] = waiting_time[i] + processes[i].burst_time;
    }

    printf("SJF Scheduling\n");
    printf("Process ID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t\t%d\t\t%d\t\t%d\n", processes[i].id, processes[i].burst_time, waiting_time[i], turnaround_time[i]);
    }
}

void round_robin_scheduling(int n, int burst_times[], int quantum) {
    int remaining_times[n], waiting_time[n], turnaround_time[n];
    int t = 0;

    for (int i = 0; i < n; i++) {
        remaining_times[i] = burst_times[i];
    }

    while (1) {
        int done = 1;
        for (int i = 0; i < n; i++) {
            if (remaining_times[i] > 0) {
                done = 0;
                if (remaining_times[i] > quantum) {
                    t += quantum;
                    remaining_times[i] -= quantum;
                } else {
                    t += remaining_times[i];
                    waiting_time[i] = t - burst_times[i];
                    remaining_times[i] = 0;
                }
            }
        }
        if (done) {
            break;
        }
    }

    for (int i = 0; i < n; i++) {
        turnaround_time[i] = burst_times[i] + waiting_time[i];
    }

    printf("Round Robin Scheduling\n");
    printf("Process ID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t\t%d\t\t%d\t\t%d\n", i + 1, burst_times[i], waiting_time[i], turnaround_time[i]);
    }
}

int compare_priority(const void *a, const void *b) {
    return ((Process *)a)->priority - ((Process *)b)->priority;
}

void priority_scheduling(int n, Process processes[]) {
    int waiting_time[n], turnaround_time[n];

    qsort(processes, n, sizeof(Process), compare_priority);

    waiting_time[0] = 0;
    turnaround_time[0] = processes[0].burst_time;

    for (int i = 1; i < n; i++) {
        waiting_time[i] = waiting_time[i - 1] + processes[i - 1].burst_time;
        turnaround_time[i] = waiting_time[i] + processes[i].burst_time;
    }

    printf("Priority Scheduling\n");
    printf("Process ID\tBurst Time\tPriority\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t\t%d\t\t%d\t\t%d\t\t%d\n", processes[i].id, processes[i].burst_time, processes[i].priority, waiting_time[i], turnaround_time[i]);
    }
}

int main() {
    int n, quantum;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    int burst_times[n];
    Process processes[n];

    printf("Enter burst times for each process:\n");
    for (int i = 0; i < n; i++) {
        printf("Burst Time for P%d: ", i + 1);
        scanf("%d", &burst_times[i]);
        processes[i].id = i + 1;
        processes[i].burst_time = burst_times[i];
    }

    printf("Enter the quantum time for Round Robin (0 to skip): ");
    scanf("%d", &quantum);

    if (quantum > 0) {
        round_robin_scheduling(n, burst_times, quantum);
    }

    printf("Enter priorities for each process:\n");
    for (int i = 0; i < n; i++) {
        printf("Priority for P%d: ", i + 1);
        scanf("%d", &processes[i].priority);
    }

    fcfs_scheduling(n, burst_times);
    sjf_scheduling(n, processes);
    priority_scheduling(n, processes);

    return 0;
}`,
                  `Program 3:Develop a C program to simulate producer-consumer problem using 
semaphores:
                    
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 10

int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;

sem_t empty;
sem_t full;
sem_t mutex;

void* producer(void* arg) {
    while (1) {
        sleep(rand() % 3);
        int item = rand() % 100;
        sem_wait(&empty);
        sem_wait(&mutex);
        buffer[in] = item;
        in = (in + 1) % BUFFER_SIZE;
        printf("Produced: %d\n", item);
        sem_post(&mutex);
        sem_post(&full);
    }
    return NULL;
}

void* consumer(void* arg) {
    while (1) {
        sleep(rand() % 3);
        sem_wait(&full);
        sem_wait(&mutex);
        int item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        printf("Consumed: %d\n", item);
        sem_post(&mutex);
        sem_post(&empty);
    }
    return NULL;
}

int main() {
    pthread_t producer_thread, consumer_thread;

    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);
    sem_init(&mutex, 0, 1);

    pthread_create(&producer_thread, NULL, producer, NULL);
    pthread_create(&consumer_thread, NULL, consumer, NULL);

    pthread_join(producer_thread, NULL);
    pthread_join(consumer_thread, NULL);

    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);

    return 0;
}`,
                
                `Program 4:Develop a C Program which demonstrate interprocess communication between 
a reader process and a writer process. Use mkfifo, open, read, write and close 
API in your program:

                
                NOT UPDATE `,
                
`Program 5:Develop a C program to simulate Bankers Algorithm for DeadLock Avoidance:

                
#include<stdio.h>
int max[100][100];
int alloc[100][100];
int need[100][100];
int avail[100];
int n, r;
void input();
void show();
void cal();
int main()
{
    printf("********** Banker's Algorithm ************\n");
    input();
    show();
    cal();
    return 0;
}

void input()
{
    int i, j;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the number of resources: ");
    scanf("%d", &r);

    printf("Enter the Max Matrix:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < r; j++) {
            scanf("%d", &max[i][j]);
        }
    }

    printf("Enter the Allocation Matrix:\n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < r; j++) {
            scanf("%d", &alloc[i][j]);
        }
    }

    printf("Enter the Available Resources:\n");
    for (j = 0; j < r; j++) {
        scanf("%d", &avail[j]);
    }
}

void show()
{
    int i, j;
    printf("\nProcess\tAllocation\tMax\t\tNeed\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t", i + 1);
        for (j = 0; j < r; j++) {
            printf("%d ", alloc[i][j]);
        }
        printf("\t");
        for (j = 0; j < r; j++) {
            printf("%d ", max[i][j]);
        }
        printf("\t");
        for (j = 0; j < r; j++) {
            need[i][j] = max[i][j] - alloc[i][j];
            printf("%d ", need[i][j]);
        }
        printf("\n");
    }
    printf("Available Resources: ");
    for (j = 0; j < r; j++) {
        printf("%d ", avail[j]);
    }
    printf("\n");
}

void cal()
{
    int finish[100] = {0}, safe[100], index = 0;
    int i, j, k, flag = 1;

    printf("\nSafe Sequence: ");
    while (flag) {
        flag = 0;
        for (i = 0; i < n; i++) {
            if (finish[i] == 0) { // Process is not yet finished
                int canAllocate = 1;
                for (j = 0; j < r; j++) {
                    if (need[i][j] > avail[j]) {
                        canAllocate = 0; // Resources are not sufficient
                        break;
                    }
                }
                if (canAllocate) {
                    for (k = 0; k < r; k++) {
                        avail[k] += alloc[i][k]; // Release resources
                    }
                    finish[i] = 1;
                    safe[index++] = i;
                    flag = 1;
                    printf("P%d ", i + 1);
                }
            }
        }
    }

    // Check if all processes are finished
    int allFinished = 1;
    for (i = 0; i < n; i++) {
        if (finish[i] == 0) {
            allFinished = 0;
            break;
        }
    }

    if (allFinished) {
        printf("\nThe system is in a safe state.\n");
    } else {
        printf("\nThe system is not in a safe state.\n");
    }
}`,
                
                
                
                 `Program 6:  Develop a C program to simulate the following contiguous memory allocation 
Techniques: 
a) Worst fit b) Best fit c) First fit :

 
 a)Worst fit:
       
#include<stdio.h>

int main()
{
    int bsize[10], psize[10], bno, pno, flags[10], allocation[10], i, j;
    
    // Initialize flags and allocation arrays
    for(i = 0; i < 10; i++)
    {
        flags[i] = 0;
        allocation[i] = -1;
    }

    // Input number of blocks and their sizes
    printf("Enter no. of blocks: ");
    scanf("%d", &bno);
    printf("\nEnter size of each block: ");
    for(i = 0; i < bno; i++)
        scanf("%d", &bsize[i]);

    // Input number of processes and their sizes
    printf("\nEnter no. of processes: ");
    scanf("%d", &pno);
    printf("\nEnter size of each process: ");
    for(i = 0; i < pno; i++)
        scanf("%d", &psize[i]);

    // First fit allocation algorithm
    for(i = 0; i < pno; i++) 
    {
        for(j = 0; j < bno; j++)
        {
            if(flags[j] == 0 && bsize[j] >= psize[i])
            {
                allocation[j] = i;
                flags[j] = 1;
                break;
            }
        }
    }

    // Display allocation details
    printf("\nBlock no.\tsize\t\tprocess no.\t\tsize");
    for(i = 0; i < bno; i++)
    {
        printf("\n%d\t\t%d\t\t", i, bsize[i]);
        if(flags[i] == 1)
            printf("%d\t\t\t%d", allocation[i], psize[allocation[i]]);
        else
            printf("Not allocated");
    }
    return 0; // Return success
}
                
                
b) Best fit:
                
#include<stdio.h>

int main()
{
    int n, n1, i;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    int process[n];
    
    printf("\nEnter the size of processes:\n");
    for(i = 0; i < n; i++) {
        scanf("%d", &process[i]);
    }

    printf("Enter the number of memory blocks: ");
    scanf("%d", &n1);
    int blocks[n1];
    int total = 0;

    printf("\nEnter the size of memory blocks:\n");
    for(i = 0; i < n1; i++) {
        scanf("%d", &blocks[i]);
        total += blocks[i];
    }

    // Arrays to store the process allocation information
    int process1[n1];
    int job[n1];
    int frag[n1];
    int check[n1];
    for(i = 0; i < n1; i++) {
        check[i] = 0; // Initially no block is allocated
    }

    int used = 0;
    int j, i1 = 0;

    // First fit allocation algorithm
    for(i = 0; i < n; i++) {
        int max = -1, j1 = -1;
        for(j = 0; j < n1; j++) {
            if(check[j] == 0 && blocks[j] >= process[i] && blocks[j] > max) {
                max = blocks[j];
                j1 = j;
            }
        }

        if(j1 != -1) { // If a suitable block is found
            process1[j1] = process[i];
            job[j1] = i + 1;  // Storing process number (1-indexed)
            frag[j1] = blocks[j1] - process[i];
            used += process[i];
            check[j1] = 1; // Mark the block as allocated
        }
    }

    // Printing the allocation results
    printf("Block size\tProcess size\tProcess no\tFragmentation\n");
    for(i = 0; i < n1; i++) {
        if(check[i] == 1) {
            printf("%d\t\t%d\t\t%d\t\t%d\n", blocks[i], process1[i], job[i], frag[i]);
        } else {
            printf("%d\t\tNot allocated\t-\t\t-\n", blocks[i]);
        }
    }

    printf("\nTotal memory allocation: %d\n", total);
    printf("Memory used: %d\n", used);
    printf("Memory left: %d\n", total - used);

    return 0;
}
                
                
                
c)First fit:

#include <stdio.h>
void implementBestFit(int blockSize[], int blocks, int processSize[], int processes)
{
    // This will store the block id of the allocated block to a process
    int allocation[processes];
    int occupied[blocks];
    
    // Initially assigning -1 to all allocation indexes
    // means nothing is allocated currently
    for (int i = 0; i < processes; i++) {
        allocation[i] = -1;
    }
    
    for (int i = 0; i < blocks; i++) {
        occupied[i] = 0;
    }

    // Pick each process and find suitable blocks according to its size and assign to it
    for (int i = 0; i < processes; i++) {
        int indexPlaced = -1;
        for (int j = 0; j < blocks; j++) {
            // If block can accommodate the process and is not occupied
            if (blockSize[j] >= processSize[i] && !occupied[j]) {
                // Place it at the first block fit to accommodate the process
                if (indexPlaced == -1)
                    indexPlaced = j;
                // If any future block is smaller than the current block where
                // process is placed, change the block (Best Fit)
                else if (blockSize[j] < blockSize[indexPlaced])
                    indexPlaced = j;
            }
        }
        
        // If we were successfully able to find block for the process
        if (indexPlaced != -1) {
            // Allocate this block to process[i]
            allocation[i] = indexPlaced;
            // Make the status of the block as occupied
            occupied[indexPlaced] = 1;
        }
    }

    // Display the allocation results
    printf("\nProcess No.\tProcess Size\tBlock No.\n");
    for (int i = 0; i < processes; i++) {
        printf("%d \t\t\t %d \t\t\t", i + 1, processSize[i]);
        if (allocation[i] != -1)
            printf("%d\n", allocation[i] + 1);
        else
            printf("Not Allocated\n");
    }
}

// Driver code
int main() {
    int blockSize[] = {100, 50, 30, 120, 35};
    int processSize[] = {40, 10, 30, 60};
    int blocks = sizeof(blockSize) / sizeof(blockSize[0]);
    int processes = sizeof(processSize) / sizeof(processSize[0]);

    implementBestFit(blockSize, blocks, processSize, processes);

    return 0;
}`,
                
                `Program 7: Develop a C program to simulate page replacement algorithms:
a) FIFO b) LRU:

a) FIFO: 
                
#include <stdio.h>
int main() {
    int i, j, n, a[50], frame[10], no, k, avail, count = 0;
    
    printf("\n ENTER THE NUMBER OF PAGES:\n");
    scanf("%d", &n);

    printf("\n ENTER THE PAGE NUMBERS:\n");
    for (i = 0; i < n; i++)  // Fixing the indexing to start from 0
        scanf("%d", &a[i]);

    printf("\n ENTER THE NUMBER OF FRAMES: ");
    scanf("%d", &no);

    for (i = 0; i < no; i++)  // Initialize frames to -1
        frame[i] = -1;

    j = 0;  // This is the index for the frames
    printf("\n\treference string\t page frames\n");

    for (i = 0; i < n; i++) {
        printf("%d\t\t", a[i]);
        avail = 0;

        // Check if the page is already in the frame
        for (k = 0; k < no; k++) {
            if (frame[k] == a[i]) {
                avail = 1;
                break;  // No need to continue checking if found
            }
        }

        // If the page is not available in frames, replace a page
        if (avail == 0) {
            frame[j] = a[i];
            j = (j + 1) % no;  // Increment frame pointer, wrap around using modulo
            count++;  // Increase page fault count
        }

        // Print the current frame contents
        for (k = 0; k < no; k++) {
            if (frame[k] != -1)  // Only print frames with pages
                printf("%d\t", frame[k]);
            else
                printf(" \t");  // Blank space for empty frames
        }
        printf("\n");
    }

    printf("Page Faults: %d\n", count);
    return 0;
}`,
                
                
                
                `Program 8: 8) Simulate following File Organization Techniques 
a) Single level directory b) Two level directory:

                
                
a)Single level directory
                
#include <stdio.h>
#include <string.h> 

struct {
    char dname[10], fname[10][10];
    int fcnt;
} dir;

int main() { 
    int i, ch;
    char f[30];
    dir.fcnt = 0;

    printf("\nEnter name of directory: ");
    scanf("%s", dir.dname);

    while (1) {
        printf("\n\n1. Create File\t2. Delete File\t3. Search File\n4. Display Files\t5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &ch);

        switch (ch) {
            case 1: // Create File
                if (dir.fcnt < 10) { // Ensure the number of files doesn't exceed the limit
                    printf("\nEnter the name of the file: ");
                    scanf("%s", dir.fname[dir.fcnt]);
                    dir.fcnt++;
                } else {
                    printf("\nDirectory is full. Cannot add more files.");
                }
                break;

            case 2: // Delete File
                printf("\nEnter the name of the file: ");
                scanf("%s", f);
                for (i = 0; i < dir.fcnt; i++) {
                    if (strcmp(f, dir.fname[i]) == 0) {
                        printf("\nFile %s is deleted.", f);
                        strcpy(dir.fname[i], dir.fname[dir.fcnt - 1]); // Replace with the last file
                        dir.fcnt--;
                        break;
                    }
                }
                if (i == dir.fcnt) {
                    printf("\nFile %s not found.", f);
                }
                break;

            case 3: // Search File
                printf("\nEnter the name of the file: ");
                scanf("%s", f);
                for (i = 0; i < dir.fcnt; i++) {
                    if (strcmp(f, dir.fname[i]) == 0) {
                        printf("\nFile %s is found.", f);
                        break;
                    }
                }
                if (i == dir.fcnt) {
                    printf("\nFile %s not found.", f);
                }
                break;

            case 4: // Display Files
                if (dir.fcnt == 0) {
                    printf("\nDirectory is empty.");
                } else {
                    printf("\nThe files are:");
                    for (i = 0; i < dir.fcnt; i++) {
                        printf("\t%s", dir.fname[i]);
                    }
                }
                break;

            case 5: // Exit
                printf("\nExiting program...");
                return 0;

            default:
                printf("\nInvalid choice. Please try again.");
        }
    }
}`,
                
                
                
                
                
                
                `Program 9: Develop a C program to simulate the Linked file allocation strategies:

                
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Block {
    int data;
    int next;
} Block;

void initializeDisk(Block disk[], int diskSize) {
    for (int i = 0; i < diskSize; i++) {
        disk[i].data = -1;
        disk[i].next = -1;
    }
}

void allocateFile(Block disk[], int diskSize, int fileSize, int *start) {
    int freeBlocks = 0;
    for (int i = 0; i < diskSize; i++) {
        if (disk[i].data == -1) freeBlocks++;
    }

    if (fileSize > freeBlocks) {
        printf("Not enough free blocks to allocate the file.\n");
        return;
    }

    int blocks[fileSize];
    int allocated = 0;

    // Find free blocks
    for (int i = 0; i < diskSize && allocated < fileSize; i++) {
        if (disk[i].data == -1) {
            blocks[allocated++] = i;
        }
    }

    // Allocate blocks
    *start = blocks[0];
    for (int i = 0; i < fileSize; i++) {
        disk[blocks[i]].data = i + 1; // Storing file data for simulation
        if (i < fileSize - 1) {
            disk[blocks[i]].next = blocks[i + 1];
        } else {
            disk[blocks[i]].next = -1; // End of file
        }
    }

    printf("File allocated starting from block %d.\n", *start);
}

void printDisk(Block disk[], int diskSize) {
    printf("Disk Status:\n");
    printf("Block\tData\tNext\n");
    for (int i = 0; i < diskSize; i++) {
        printf("%d\t%d\t%d\n", i, disk[i].data, disk[i].next);
    }
}

void displayFile(Block disk[], int start) {
    if (start == -1) {
        printf("No file allocated.\n");
        return;
    }

    printf("File blocks: ");
    int current = start;
    while (current != -1) {
        printf("%d -> ", current);
        current = disk[current].next;
    }
    printf("NULL\n");
}

int main() {
    int diskSize = 10;
    Block disk[diskSize];
    initializeDisk(disk, diskSize);

    int choice, fileSize, start = -1;

    while (true) {
        printf("\n1. Allocate File\n2. Print Disk\n3. Display File\n4. Exit\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter file size (in blocks): ");
                scanf("%d", &fileSize);
                allocateFile(disk, diskSize, fileSize, &start);
                break;
            case 2:
                printDisk(disk, diskSize);
                break;
            case 3:
                displayFile(disk, start);
                break;
            case 4:
                printf("Exiting program.\n");
                return 0;
            default:
                printf("Invalid choice. Try again.\n");
        }
    }

    return 0;
}`,
                
                
                
                
                `Program 10: Develop a C program to simulate SCAN disk scheduling algorithm.:

                
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 10
#define DISK_SIZE 200

int comp(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

void SCAN(int arr[], int size, int head, const char* direction) {
    int seek_count = 0;
    int distance, cur_track;
    int left[SIZE], right[SIZE];
    int seek_sequence[SIZE + 2]; // Maximum possible size
    int left_count = 0, right_count = 0;

    // Adding 0 or DISK_SIZE-1 to simulate end points
    if (strcmp(direction, "left") == 0) {
        left[left_count++] = 0;
    } else if (strcmp(direction, "right") == 0) {
        right[right_count++] = DISK_SIZE - 1;
    }

    // Separating requests into left and right of the head
    for (int i = 0; i < size; i++) {
        if (arr[i] < head) {
            left[left_count++] = arr[i];
        } else {
            right[right_count++] = arr[i];
        }
    }

    // Sorting both sides
    qsort(left, left_count, sizeof(int), comp);
    qsort(right, right_count, sizeof(int), comp);

    int index = 0;

    // Scanning in the specified direction
    if (strcmp(direction, "left") == 0) {
        for (int i = left_count - 1; i >= 0; i--) {
            cur_track = left[i];
            seek_sequence[index++] = cur_track;
            distance = abs(cur_track - head);
            seek_count += distance;
            head = cur_track;
        }
        for (int i = 0; i < right_count; i++) {
            cur_track = right[i];
            seek_sequence[index++] = cur_track;
            distance = abs(cur_track - head);
            seek_count += distance;
            head = cur_track;
        }
    } else if (strcmp(direction, "right") == 0) {
        for (int i = 0; i < right_count; i++) {
            cur_track = right[i];
            seek_sequence[index++] = cur_track;
            distance = abs(cur_track - head);
            seek_count += distance;
            head = cur_track;
        }
        for (int i = left_count - 1; i >= 0; i--) {
            cur_track = left[i];
            seek_sequence[index++] = cur_track;
            distance = abs(cur_track - head);
            seek_count += distance;
            head = cur_track;
        }
    }

    // Output results
    printf("Total seek operations = %d\n", seek_count);
    printf("Seek Sequence is:\n");
    for (int i = 0; i < index; i++) {
        printf("%d ", seek_sequence[i]);
    }
    printf("\n");
}

int main() {
    int arr[SIZE] = {126, 90, 14, 50, 25, 42, 51, 78, 102, 100};
    int head = 42;
    char direction[] = "left";

    SCAN(arr, SIZE, head, direction);

    return 0;
}`,
                
                
                
                
                
                
                
                

                    
                ],
                ds: [
                    `Program 1:a. Declare a calendar as an array of 7 elements (A dynamically Created array) to represent 7 days of a 
week. Each Element of the array is a structure having three fields. The first field is the name of the 
Day (A dynamically allocated String), The second field is the date of the Day (A integer), the third 
field is the description of the activity for a particular day (A dynamically allocated String):
                    
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char *dayName;
    int date;
    char *activity;
} Day;

int main() {
    Day *week = (Day *)malloc(7 * sizeof(Day));
    for (int i = 0; i < 7; i++) {
        week[i].dayName = (char *)malloc(20 * sizeof(char));
        week[i].activity = (char *)malloc(50 * sizeof(char));
        sprintf(week[i].dayName, "Day%d", i + 1);
        week[i].date = i + 1;
        sprintf(week[i].activity, "Activity%d", i + 1);
    }
    for (int i = 0; i < 7; i++) {
        printf("%s %d %s\n", week[i].dayName, week[i].date, week[i].activity);
        free(week[i].dayName);
        free(week[i].activity);
    }
    free(week);
    return 0;
}

    
    
1b.Write functions create(), read() and display(); to create the calendar, to read the data from the keyboard and to print weeks activity details report on screen:
   
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char *dayName;
    int date;
    char *activity;
} Day;

Day *create() {
    Day *week = malloc(7 * sizeof(Day));
    for (int i = 0; i < 7; i++) {
        week[i].dayName = malloc(20);
        week[i].activity = malloc(50);
    }
    return week;
}

void read(Day *week) {
    for (int i = 0; i < 7; i++) {
        printf("Enter Day Name, Date, Activity for Day %d: ", i + 1);
        scanf("%s %d", week[i].dayName, &week[i].date);
        getchar(); fgets(week[i].activity, 50, stdin);
    }
}

void display(Day *week) {
    for (int i = 0; i < 7; i++)
        printf("%s %d %s", week[i].dayName, week[i].date, week[i].activity);
}

int main() {
    Day *week = create();
    read(week);
    display(week);
    for (int i = 0; i < 7; i++) free(week[i].dayName), free(week[i].activity);
    free(week);
    return 0;
}`,
              `Program 2: a. Read a main String (STR), a Pattern String (PAT) and a Replace String (REP).:
                    
    #include <stdio.h>
#include <string.h>

void replaceSubstring(char *str, char *pat, char *rep) {
    char result[500], *pos;
    int index = 0, patLen = strlen(pat);
    result[0] = '\0';

    while ((pos = strstr(str, pat))) {
        index = pos - str;
        strncat(result, str, index);
        strcat(result, rep);
        str += index + patLen;
    }
    strcat(result, str);
    strcpy(str, result);
}

int main() {
    char str[500], pat[100], rep[100];
    printf("Enter Main String: "); fgets(str, 500, stdin);
    printf("Enter Pattern String: "); fgets(pat, 100, stdin);
    printf("Enter Replace String: "); fgets(rep, 100, stdin);

    str[strcspn(str, "\n")] = '\0';
    pat[strcspn(pat, "\n")] = '\0';
    rep[strcspn(rep, "\n")] = '\0';

    replaceSubstring(str, pat, rep);
    printf("Resultant String: %s\n", str);
    return 0;
}
    
    
    
    2b.Perform Pattern Matching Operation: Find and Replace all occurrences of PAT in STR with REP if 
PAT exists in STR. Report suitable messages in case PAT does not exist in STR.:
    
#include <stdio.h>
#include <string.h>

void replaceSubstring(char *str, char *pat, char *rep) {
    char result[500], *pos;
    int patLen = strlen(pat), found = 0;
    result[0] = '\0';

    while ((pos = strstr(str, pat))) {
        found = 1;
        strncat(result, str, pos - str);
        strcat(result, rep);
        str = pos + patLen;
    }
    strcat(result, str);
    if (found) {
        strcpy(str, result);
        printf("Resultant String: %s\n", str);
    } else {
        printf("Pattern not found in the string.\n");
    }
}

int main() {
    char str[500], pat[100], rep[100];
    printf("Enter Main String: "); fgets(str, 500, stdin);
    printf("Enter Pattern String: "); fgets(pat, 100, stdin);
    printf("Enter Replace String: "); fgets(rep, 100, stdin);

    str[strcspn(str, "\n")] = '\0';
    pat[strcspn(pat, "\n")] = '\0';
    rep[strcspn(rep, "\n")] = '\0';

    replaceSubstring(str, pat, rep);
    return 0;
}`,
              
              
              `Program 3: Develop a menu driven Program in C for the following operations on STACK of Integers (Array 
Implementation of Stack with maximum size MAX):
                    
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 100

int stack[MAX], top = -1;

void push(int x) {
    if (top == MAX - 1) {
        printf("Stack Overflow\n");
        return;
    }
    stack[++top] = x;
    printf("Pushed: %d\n", x);
}

void pop() {
    if (top == -1) {
        printf("Stack Underflow\n");
        return;
    }
    printf("Popped: %d\n", stack[top--]);
}

void checkPalindrome() {
    if (top == -1) {
        printf("Stack is empty, cannot check palindrome\n");
        return;
    }
    int isPalindrome = 1;
    for (int i = 0; i <= top / 2; i++) {
        if (stack[i] != stack[top - i]) {
            isPalindrome = 0;
            break;
        }
    }
    printf("Stack is %s\n", isPalindrome ? "a Palindrome" : "not a Palindrome");
}

void display() {
    if (top == -1) {
        printf("Stack is Empty\n");
        return;
    }
    printf("Stack: ");
    for (int i = 0; i <= top; i++)
        printf("%d ", stack[i]);
    printf("\n");
}

int main() {
    int choice, x;
    while (1) {
        printf("\n1. Push\n2. Pop\n3. Check Palindrome\n4. Display\n5. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter element to push: ");
                scanf("%d", &x);
                push(x);
                break;
            case 2:
                pop();
                break;
            case 3:
                checkPalindrome();
                break;
            case 4:
                display();
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }
    return 0;
}`,
              
              
               `Program 4: Develop a Program in C for converting an Infix Expression to Postfix Expression. Program should 
support for both parenthesized and free parenthesized expressions with the operators: +, -, *, /, 
(Remainder), ^ (Power) and alphanumeric operands.:
              
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#define MAX 100

char stack[MAX];
int top = -1;

void push(char c) {
    stack[++top] = c;
}

char pop() {
    return (top == -1) ? '\0' : stack[top--];
}

int precedence(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/' || c == '%') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

int isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^';
}

void infixToPostfix(char *infix, char *postfix) {
    int i = 0, j = 0;
    char c;
    while ((c = infix[i++]) != '\0') {
        if (isalnum(c)) {
            postfix[j++] = c;
        } else if (c == '(') {
            push(c);
        } else if (c == ')') {
            while (top != -1 && stack[top] != '(')
                postfix[j++] = pop();
            pop();  // Remove '('
        } else if (isOperator(c)) {
            while (top != -1 && precedence(stack[top]) >= precedence(c))
                postfix[j++] = pop();
            push(c);
        }
    }
    while (top != -1)
        postfix[j++] = pop();
    postfix[j] = '\0';
}

int main() {
    char infix[MAX], postfix[MAX];
    printf("Enter Infix Expression: ");
    scanf("%s", infix);
    infixToPostfix(infix, postfix);
    printf("Postfix Expression: %s\n", postfix);
    return 0;
}`,
              
              
              
               `Program 5:a.Evaluation of Suffix expression with single digit operands and operators: +, -, *, /, %,^.:
                    
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#define MAX 100

int stack[MAX], top = -1;

void push(int x) {
    stack[++top] = x;
}

int pop() {
    return stack[top--];
}

int evaluatePostfix(char *exp) {
    for (int i = 0; exp[i] != '\0'; i++) {
        if (isdigit(exp[i])) {
            push(exp[i] - '0');
        } else {
            int b = pop(), a = pop();
            switch (exp[i]) {
                case '+': push(a + b); break;
                case '-': push(a - b); break;
                case '*': push(a * b); break;
                case '/': push(a / b); break;
                case '%': push(a % b); break;
                case '^': push(pow(a, b)); break;
            }
        }
    }
    return pop();
}

int main() {
    char exp[MAX];
    printf("Enter Postfix Expression: ");
    scanf("%s", exp);
    printf("Result: %d\n", evaluatePostfix(exp));
    return 0;
}
    
    
    
    5b. Solving Tower of Hanoi problem with n disks:
    
#include <stdio.h>
#include <math.h>

void tower(int n, char source, char temp, char destination) {
    if (n == 0)
        return;
    tower(n - 1, source, destination, temp);
    printf("\nMove disc %d from %c to %c", n, source, destination);
    tower(n - 1, temp, source, destination);
}

int main() {
    int n;
    printf("Enter the number of discs: ");
    scanf("%d", &n);
    tower(n, 'A', 'B', 'C');
    printf("\n\nTotal Number of moves are: %d\n", (int)pow(2, n) - 1);
    return 0;
}`,
              
              
              
              
               `Program 6:Design, Develop and Implement a menu driven Program in C for the following operations on 
Circular QUEUE of Characters (Array Implementation of Queue with maximum size MAX):
                    
#include <stdio.h>
#include <stdlib.h>
#define MAX 5

char queue[MAX];
int front = -1, rear = -1;

void insert(char c) {
    if ((rear + 1) % MAX == front) {
        printf("Queue Overflow\n");
        return;
    }
    if (front == -1) front = 0;
    rear = (rear + 1) % MAX;
    queue[rear] = c;
    printf("Inserted: %c\n", c);
}

void delete() {
    if (front == -1) {
        printf("Queue Underflow\n");
        return;
    }
    printf("Deleted: %c\n", queue[front]);
    if (front == rear) {
        front = rear = -1;
    } else {
        front = (front + 1) % MAX;
    }
}

void display() {
    if (front == -1) {
        printf("Queue is Empty\n");
        return;
    }
    printf("Queue: ");
    int i = front;
    while (i != rear) {
        printf("%c ", queue[i]);
        i = (i + 1) % MAX;
    }
    printf("%c\n", queue[rear]);
}

int main() {
    char choice, c;
    while (1) {
        printf("\nMenu:\n");
        printf("a. Insert\nb. Delete\nc. Display\n");
        printf("d. Exit\nEnter choice: ");
        scanf(" %c", &choice);
        switch (choice) {
            case 'a':
                printf("Enter character to insert: ");
                scanf(" %c", &c);
                insert(c);
                break;
            case 'b':
                delete();
                break;
            case 'c':
                display();
                break;
            case 'd':
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }
    return 0;
}`,
              
              
              `Program 7: Design, Develop and Implement a menu driven Program in C for the following operations on
Singly Linked List (SLL) of Student Data with the fields: USN, Name, Branch, Sem, PhNo
a. Create a SLL of N Students Data by using front insertion.
b. Display the status of SLL and count the number of nodes in it
c. Perform Insertion and Deletion at End of SLL
d. Perform Insertion and Deletion at Front of SLL
e. Demonstrate how this SLL can be used as STACK and QUEUE
f. Exit:
                    
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Student {
    char USN[15], Name[30], Branch[20], PhNo[15];
    int Sem;
    struct Student *next;
};

struct Student *head = NULL;

void insertFront() {
    struct Student *newNode = (struct Student *)malloc(sizeof(struct Student));
    printf("Enter USN, Name, Branch, Sem, PhNo: ");
    scanf("%s %s %s %d %s", newNode->USN, newNode->Name, newNode->Branch, &newNode->Sem, newNode->PhNo);
    newNode->next = head;
    head = newNode;
}

void insertEnd() {
    struct Student *newNode = (struct Student *)malloc(sizeof(struct Student));
    printf("Enter USN, Name, Branch, Sem, PhNo: ");
    scanf("%s %s %s %d %s", newNode->USN, newNode->Name, newNode->Branch, &newNode->Sem, newNode->PhNo);
    newNode->next = NULL;
    if (!head) { head = newNode; return; }
    struct Student *temp = head;
    while (temp->next) temp = temp->next;
    temp->next = newNode;
}

void deleteEnd() {
    if (!head) { printf("List Empty\n"); return; }
    if (!head->next) { free(head); head = NULL; return; }
    struct Student *temp = head;
    while (temp->next->next) temp = temp->next;
    free(temp->next);
    temp->next = NULL;
}

void display() {
    if (!head) { printf("List Empty\n"); return; }
    struct Student *temp = head;
    while (temp) {
        printf("%s %s %s %d %s\n", temp->USN, temp->Name, temp->Branch, temp->Sem, temp->PhNo);
        temp = temp->next;
    }
}

void stackQueueDemo(int choice) {
    if (choice == 1) insertFront(); 
    else if (choice == 2) insertEnd();
    else printf("Invalid choice\n");
}

int main() {
    int choice;
    while (1) {
        printf("\n1. Insert Front\n2. Insert End\n3. Delete End\n4. Display\n5. Stack/Queue Demo\n6. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1: insertFront(); break;
            case 2: insertEnd(); break;
            case 3: deleteEnd(); break;
            case 4: display(); break;
            case 5: 
                printf("1. Stack (Insert at Front)\n2. Queue (Insert at End)\n");
                scanf("%d", &choice); stackQueueDemo(choice); break;
            case 6: exit(0);
            default: printf("Invalid choice\n");
        }
    }
    return 0;
}`,
              
              
              
              `Program 8: Design, Develop and Implement a menu driven Program in C for the following operations on
Doubly Linked List (DLL) of Employee Data with the fields: SSN, Name, Dept, Designation, Sal,
PhNo.
a. Create a DLL of N Employees Data by using end insertion.
b. Display the status of DLL and count the number of nodes in it
c. Perform Insertion and Deletion at End of DLL
d. Perform Insertion and Deletion at Front of DLL
e. Demonstrate how this DLL can be used as Double Ended Queue
f. Exit:
                    
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Employee {
    char SSN[15], Name[30], Dept[20], Designation[20], PhNo[15];
    float Sal;
    struct Employee *prev, *next;
};

struct Employee *head = NULL, *tail = NULL;

void insertEnd() {
    struct Employee *newNode = (struct Employee *)malloc(sizeof(struct Employee));
    printf("Enter SSN, Name, Dept, Designation, Sal, PhNo: ");
    scanf("%s %s %s %s %f %s", newNode->SSN, newNode->Name, newNode->Dept, newNode->Designation, &newNode->Sal, newNode->PhNo);
    newNode->next = NULL;
    if (!head) { head = tail = newNode; newNode->prev = NULL; return; }
    tail->next = newNode;
    newNode->prev = tail;
    tail = newNode;
}

void deleteEnd() {
    if (!tail) { printf("List Empty\n"); return; }
    if (!tail->prev) { free(tail); head = tail = NULL; return; }
    struct Employee *temp = tail;
    tail = tail->prev;
    tail->next = NULL;
    free(temp);
}

void insertFront() {
    struct Employee *newNode = (struct Employee *)malloc(sizeof(struct Employee));
    printf("Enter SSN, Name, Dept, Designation, Sal, PhNo: ");
    scanf("%s %s %s %s %f %s", newNode->SSN, newNode->Name, newNode->Dept, newNode->Designation, &newNode->Sal, newNode->PhNo);
    newNode->prev = NULL;
    newNode->next = head;
    if (head) head->prev = newNode;
    head = newNode;
    if (!tail) tail = head;
}

void deleteFront() {
    if (!head) { printf("List Empty\n"); return; }
    struct Employee *temp = head;
    head = head->next;
    if (head) head->prev = NULL;
    else tail = NULL;
    free(temp);
}

void display() {
    if (!head) { printf("List Empty\n"); return; }
    struct Employee *temp = head;
    while (temp) {
        printf("%s %s %s %s %.2f %s\n", temp->SSN, temp->Name, temp->Dept, temp->Designation, temp->Sal, temp->PhNo);
        temp = temp->next;
    }
}

void doubleEndedQueueDemo(int choice) {
    if (choice == 1) insertFront();  // Insert at Front
    else if (choice == 2) insertEnd();  // Insert at End
    else if (choice == 3) deleteFront();  // Delete from Front
    else if (choice == 4) deleteEnd();  // Delete from End
    else printf("Invalid choice\n");
}

int main() {
    int choice;
    while (1) {
        printf("\n1. Insert End\n2. Delete End\n3. Insert Front\n4. Delete Front\n5. Display\n6. Double Ended Queue Demo\n7. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1: insertEnd(); break;
            case 2: deleteEnd(); break;
            case 3: insertFront(); break;
            case 4: deleteFront(); break;
            case 5: display(); break;
            case 6:
                printf("1. Insert Front\n2. Insert End\n3. Delete Front\n4. Delete End\n");
                int subChoice;
                scanf("%d", &subChoice);
                doubleEndedQueueDemo(subChoice); break;
            case 7: exit(0);
            default: printf("Invalid choice\n");
        }
    }
    return 0;
}`,
              
              
              
               `Program 9:Design, Develop and Implement a Program in C for the following operations on Singly Circular
Linked List (SCLL) with header nodes
a. Represent and Evaluate a Polynomial P(x,y,z) = 6x2y2z-4yz5+3x3yz+2xy5z-2xyz3
b. Find the sum of two polynomials POLY1(x,y,z) and POLY2(x,y,z) and store the result in
POLYSUM(x,y,z):

              
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

struct Term {
    int coeff, x_exp, y_exp, z_exp;
    struct Term* next;
};

void insertEnd(struct Term** header, int coeff, int x, int y, int z) {
    struct Term* newTerm = (struct Term*)malloc(sizeof(struct Term));
    newTerm->coeff = coeff;
    newTerm->x_exp = x;
    newTerm->y_exp = y;
    newTerm->z_exp = z;
    newTerm->next = *header ? *header : newTerm;
    if (*header) {
        struct Term* temp = *header;
        while (temp->next != *header) temp = temp->next;
        temp->next = newTerm;
    } else {
        *header = newTerm;
    }
}

void display(struct Term* header) {
    struct Term* temp = header;
    do {
        printf("%dx^%dy^%dz^%d ", temp->coeff, temp->x_exp, temp->y_exp, temp->z_exp);
        if (temp->next != header) printf("+ ");
        temp = temp->next;
    } while (temp != header);
    printf("\n");
}

int evaluate(struct Term* header, int x, int y, int z) {
    int result = 0;
    struct Term* temp = header;
    do {
        result += temp->coeff * pow(x, temp->x_exp) * pow(y, temp->y_exp) * pow(z, temp->z_exp);
        temp = temp->next;
    } while (temp != header);
    return result;
}

struct Term* sumPolynomials(struct Term* poly1, struct Term* poly2) {
    struct Term* result = NULL;
    struct Term *p1 = poly1, *p2 = poly2;
    while (p1 || p2) {
        if (!p1) {
            insertEnd(&result, p2->coeff, p2->x_exp, p2->y_exp, p2->z_exp);
            p2 = p2->next;
        } else if (!p2) {
            insertEnd(&result, p1->coeff, p1->x_exp, p1->y_exp, p1->z_exp);
            p1 = p1->next;
        } else if (p1->x_exp == p2->x_exp && p1->y_exp == p2->y_exp && p1->z_exp == p2->z_exp) {
            insertEnd(&result, p1->coeff + p2->coeff, p1->x_exp, p1->y_exp, p1->z_exp);
            p1 = p1->next;
            p2 = p2->next;
        } else if (p1->x_exp < p2->x_exp) {
            insertEnd(&result, p1->coeff, p1->x_exp, p1->y_exp, p1->z_exp);
            p1 = p1->next;
        } else {
            insertEnd(&result, p2->coeff, p2->x_exp, p2->y_exp, p2->z_exp);
            p2 = p2->next;
        }
    }
    return result;
}

int main() {
    struct Term *poly1 = NULL, *poly2 = NULL, *polySum = NULL;
    insertEnd(&poly1, 6, 2, 2, 1); insertEnd(&poly1, -4, 0, 1, 5);
    insertEnd(&poly1, 3, 3, 1, 1); insertEnd(&poly1, 2, 1, 5, 1);
    insertEnd(&poly1, -2, 1, 1, 3);

    insertEnd(&poly2, 3, 3, 1, 1); insertEnd(&poly2, 5, 1, 2, 2);

    printf("Polynomial 1:\n"); display(poly1);
    printf("Polynomial 2:\n"); display(poly2);

    polySum = sumPolynomials(poly1, poly2);
    printf("Sum of Polynomials:\n"); display(polySum);

    printf("Polynomial 1 evaluated at (x=1, y=2, z=3): %d\n", evaluate(poly1, 1, 2, 3));

    return 0;
}`,
              
              
              `Program 10:Design, Develop and Implement a menu driven Program in C for the following operations on Binary
Search Tree (BST) of Integers
a. Create a BST of N Integers: 6, 9, 5, 2, 8, 15, 24, 14, 7, 8, 5, 2
b. Traverse the BST in Inorder, Preorder and Post Order
c. Search the BST for a given element (KEY) and report the appropriate message
d. Delete an element (ELEM) from BST
e. Exit:
                    
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL) return createNode(data);
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    return root;
}

// Inorder Traversal
void inorder(struct Node* root) {
    if (root) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Preorder Traversal
void preorder(struct Node* root) {
    if (root) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder Traversal
void postorder(struct Node* root) {
    if (root) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

// Function to search for a key in the BST
struct Node* search(struct Node* root, int key) {
    if (root == NULL || root->data == key) return root;
    if (key < root->data) return search(root->left, key);
    return search(root->right, key);
}

// Function to delete a node from the BST
struct Node* delete(struct Node* root, int data) {
    if (root == NULL) return root;
    if (data < root->data)
        root->left = delete(root->left, data);
    else if (data > root->data)
        root->right = delete(root->right, data);
    else {
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }
        struct Node* temp = root->right;
        while (temp && temp->left) temp = temp->left;
        root->data = temp->data;
        root->right = delete(root->right, temp->data);
    }
    return root;
}

int main() {
    struct Node* root = NULL;
    int elements[] = {6, 9, 5, 2, 8, 15, 24, 14, 7, 8, 5, 2};
    for (int i = 0; i < sizeof(elements)/sizeof(elements[0]); i++) {
        root = insert(root, elements[i]);
    }

    int choice, key;
    do {
        printf("\nMenu:\n1. Inorder\n2. Preorder\n3. Postorder\n4. Search\n5. Delete\n6. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Inorder Traversal: ");
                inorder(root);
                break;
            case 2:
                printf("Preorder Traversal: ");
                preorder(root);
                break;
            case 3:
                printf("Postorder Traversal: ");
                postorder(root);
                break;
            case 4:
                printf("Enter key to search: ");
                scanf("%d", &key);
                if (search(root, key)) printf("Element found.\n");
                else printf("Element not found.\n");
                break;
            case 5:
                printf("Enter element to delete: ");
                scanf("%d", &key);
                root = delete(root, key);
                printf("Element deleted.\n");
                break;
            case 6:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice!\n");
        }
    } while (choice != 6);

    return 0;
}`,
              
              
               `Program 11:Design, Develop and Implement a Program in C for the following operations on Graph(G) of Cities
a. Create a Graph of N cities using AdjacencyMatrix.
b. Print all the nodes reachable from a given starting node in a digraph using BFS method
c. Check whether a given graph is connected or not using DFS method.
:
                    
#include <stdio.h>
#include <stdlib.h>
#define MAX 10
int graph[MAX][MAX], visited[MAX];
void createGraph(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &graph[i][j]);
        }
    }
}

void BFS(int start, int n) {
    int queue[MAX], front = 0, rear = 0;
    visited[start] = 1;
    queue[rear++] = start;
    while (front < rear) {
        int current = queue[front++];
        printf("%d ", current + 1);
        for (int i = 0; i < n; i++) {
            if (graph[current][i] == 1 && !visited[i]) {
                visited[i] = 1;
                queue[rear++] = i;
            }
        }
    }
    printf("\n");
}

void DFS(int node, int n) {
    visited[node] = 1;
    for (int i = 0; i < n; i++) {
        if (graph[node][i] == 1 && !visited[i]) {
            DFS(i, n);
        }
    }
}

int isConnected(int n) {
    for (int i = 0; i < n; i++) visited[i] = 0;
    DFS(0, n);
    for (int i = 0; i < n; i++) {
        if (!visited[i]) return 0;
    }
    return 1;
}

int main() {
    int n, start, choice;
    scanf("%d", &n);
    createGraph(n);
    do {
        printf("\n1. BFS\n2. Check connectivity\n3. Exit\n");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                scanf("%d", &start);
                for (int i = 0; i < n; i++) visited[i] = 0;
                BFS(start - 1, n);
                break;
            case 2:
                printf(isConnected(n) ? "Connected\n" : "Not Connected\n");
                break;
            case 3:
                break;
            default:
                printf("Invalid\n");
        }
    } while (choice != 3);
    return 0;
}`,
              
              
              
              `Program 12:Given a File of N employee records with a set K of Keys(4-digit) which uniquely determine the
records in file F. Assume that file F is maintained in memory by a Hash Table(HT) of m memory
locations with L as the set of memory addresses (2-digit) of locations in HT. Let the keys in K and
addresses in L are Integers. Design and develop a Program in C that uses Hash function H: K ®L as
H(K)=K mod m (remainder method), and implement hashing technique to map a given key K to
the address space L. Resolve the collision (if any) using linear probing. :
              
                    
#include <stdio.h>
#include <stdlib.h>
#define MAX 10

struct employee {
    int id;
    char name[15];
};

typedef struct employee EMP;

EMP emp[MAX];
int a[MAX];

int create(int num) {
    return num % MAX;
}

int getemp(int key) {
    printf("\nEnter emp id: ");
    scanf("%d", &emp[key].id);
    printf("\nEnter emp name: ");
    scanf("%s", emp[key].name);
    return key;
}

void display() {
    int i, ch;
    printf("\n1. Display ALL\n2. Filtered Display\nEnter the choice: ");
    scanf("%d", &ch);

    printf("\nHTKey\tEmpID\tEmpName");
    for (i = 0; i < MAX; i++) {
        if (a[i] != -1 || ch == 1) {
            printf("\n%d\t%d\t%s", i, emp[i].id, emp[i].name);
        }
    }
}

void linear_prob(int key, int num) {
    int i, flag = 0;
    
    if (a[key] != -1) {
        printf("\nCollision Detected...!!!\n");
        for (i = key; i < MAX; i++) {
            if (a[i] == -1) {
                a[i] = num;
                flag = 1;
                break;
            }
        }
        if (!flag) {
            for (i = 0; i < key; i++) {
                if (a[i] == -1) {
                    a[i] = num;
                    flag = 1;
                    break;
                }
            }
        }
        if (!flag) {
            printf("\nHash table is full\n");
            exit(1);
        }
        printf("\nCollision avoided successfully using LINEAR PROBING\n");
    } else {
        a[key] = num;
    }
}

int main() {
    int num, key, i;
    int ans = 1;

    for (i = 0; i < MAX; i++) {
        a[i] = -1;
    }

    printf("\nCollision handling by linear probing: ");
    do {
        printf("\nEnter emp number: ");
        scanf("%d", &num);
        key = create(num);
        getemp(key);
        linear_prob(key, num);

        printf("\nDo you wish to continue? (1/0): ");
        scanf("%d", &ans);
    } while (ans);

    display();
    return 0;
}`,
    
    
    
              
              
              
              
    
    
  
    
                   
    
    
              
                    
                ],
                python: [
                    `Program 1: 1a. Calculate average of best 2 out of 3 tests:
                    
    marks1 = int(input("Enter marks for test1 : "))
    marks2 = int(input("Enter marks for test2 : "))
    marks3 = int(input("Enter marks for test3 : "))
    
    minimum = min(marks1, marks2, marks3)
    sumof2 = marks1 + marks2 + marks3 - minimum
    avgof2 = sumof2 / 2
    print("Average of best 2 =", avgof2)
    
    
    
    
    1b.The given number is palindrome or not:
    
num = input("Enter a number: ")
print(f"{num} is a palindrome." if num == num[::-1] else f"{num} is not a palindrome.")`,
    
                        `Program 2: 2a Fibonacci sequence program:
                        
n = int(input("Enter the number of terms: "))
a, b = 0, 1
for _ in range(n - 1):
    a, b = b, a + b
print(a)

 

2b: Binary to decimal and octal to hexadecimal:

def binary_to_decimal(binary_str):
    return int(binary_str, 2)

def octal_to_hexadecimal(octal_str):
    return hex(int(octal_str, 8))[2:]

binary = input("Enter a binary number: ")
octal = input("Enter an octal number: ")

print("Binary to Decimal:", binary_to_decimal(binary))
print("Octal to Hexadecimal:", octal_to_hexadecimal(octal))`,


   `Program 3: 3a Upper case, lower case and digits:
                    
sentence = input("Enter a sentence: ")
words = len(sentence.split())
digits = sum(c.isdigit() for c in sentence)
upper = sum(c.isupper() for c in sentence)
lower = sum(c.islower() for c in sentence)
print(f"Words: {words}, Digits: {digits}, Uppercase: {upper}, Lowercase: {lower}")

 

3b: Similarity between two said strings

str1, str2 = input("Enter String 1: "), input("Enter String 2: ")
similarity = sum(1 for a, b in zip(str1.lower(), str2.lower()) if a == b) / max(len(str1), len(str2))
print(f"Similarity between two said strings:\n{similarity:.1f}")`,
    
    
    
    
    
    
`Program 4: 4a Demonstrate how to Draw a Bar Plot using Matplotlib   

import matplotlib.pyplot as plt 

x = [1, 2, 3, 4, 5] 

y = [3, 5, 7, 2, 1] 
plt.bar(x, y, color='green') 
plt.title('Bar Plot Example') 
plt.xlabel('X Axis') 
plt.ylabel('Y Axis') 
plt.show()



4b:Draw a Scatter Plot using Matplotlib:

import matplotlib.pyplot as plt 
import numpy as np 
x = np.random.randn(100) 
y = np.random.randn(100) 
plt.scatter(x, y) 
plt.title('Scatter Plot') 
plt.xlabel('X') 
plt.ylabel('Y') 
plt.show()`,



`Program 5: 5a Demonstrate how to Draw a Histogram Plot using Matplotlib

import matplotlib.pyplot as plt 
import numpy as np 
data = np.random.normal(100, 10, 1000) 
plt.hist(data, bins=20, edgecolor='black') 
plt.xlabel('Value') 
plt.ylabel('Frequency') 
plt.title('Histogram of Data') 
plt.grid(True) 
plt.show()



5b:Demonstrate how to Draw a Pie Chart using Matplotlib

import matplotlib.pyplot as plt 
labels = ['A', 'B', 'C', 'D'] 
sizes = [15, 30, 45, 10] 
plt.pie(sizes, labels=labels, autopct="%1.1f%%") 
plt.title("Pie Chart") 
plt.show()`,



`Program 6: 6a Linear Plotting using Matplotlib:

import matplotlib.pyplot as plt 
import numpy as np 
X = np.array([2, 4, 6, 8, 10]) 
Y = X * 2 
plt.plot(X, Y) 
plt.xlabel("X-axis Label") 
plt.ylabel("Y-axis Label") 
plt.title("This is the title of of the plot") 
plt.show()


6b:liner plotting with line formatting using Matplotlib

import matplotlib.pyplot as plt 
import numpy as np 
x = np.linspace(0, 10, 100) 
y = np.sin(x) 
plt.plot(x, y, color='blue', linestyle='-', linewidth=2) 
plt.title('Line Plot') 
plt.xlabel('X Axis') 
plt.ylabel('Y Axis') 
plt.show()`,


`Program 7:seaborn plots with Aesthetic functions:

import seaborn as sns 
import matplotlib.pyplot as plt 
tips = sns.load_dataset("tips") 
sns.scatterplot(x="total_bill", y="tip", data=tips) 
sns.set_style("whitegrid") 
sns.set_palette("Set2") 
sns.despine() 
plt.show()`,

`Program 8: plotting different types of plots using Bokeh:

from bokeh.plotting import figure, show 
x = [1, 2, 3, 4, 5] 
y = [6, 7, 2, 4, 5] 
p = figure(title="Interactive line graph", x_axis_label='x', y_axis_label='y') 
p.line(x, y, legend_label="Line", line_width=2) 
p.annular_wedge(x=5, y=5, inner_radius=0.2, outer_radius=0.4, start_angle=45, end_angle=135, 
line_color="red", fill_color="red") 
show(p)`,


`Program 9:  draw 3D Plots using Plotly Libraries:

import plotly.graph_objects as go 
import numpy as npx = np.linspace(0, 10, 100) 
y = np.linspace(0, 10, 100) 
z = np.random.randn(100, 100) 
fig = go.Figure(data=[go.Scatter3d(x=x, y=y, z=z, mode='markers')]) 
fig.update_layout(title='3D Scatter Plot', scene=dict(xaxis_title='X Axis', yaxis_title='Y Axis', zaxis_title='Z 
Axis')) 
fig.show()`,


`Program 10: 10a draw Time Series using Plotly Libraries:

import plotly.graph_objects as godata = [ 
{'x': [1, 2, 3, 4, 5], 'y': [6, 7, 2, 4, 5]}, 
{'x': [6, 7, 8, 9, 10], 'y': [1, 3, 5, 7, 9]} 
] 
fig = go.Figure() 
for i in range(len(data)): 
fig.add_trace(go.Scatter(x=data[i]['x'], y=data[i]['y'], mode='lines')) 
fig.update_layout(title='Time Series', xaxis_title='Time', yaxis_title='Value') 
fig.show()


Program 10b: creating Maps using Plotly Libraries:

import plotly.express as px 
df = px.data.election() 
geojson = px.data.election_geojson() 
fig = px.choropleth(df, geojson=geojson, color="Bergeron",locations="district", 
featureidkey="properties.district",projection="mercator") 
fig.update_geos(fitbounds="locations", visible=True) 
fig.update_layout(margin={"r": 0, "t": 0, "l": 0, "b": 0}) 
fig.show()`
                ]
            },
            
            sem4: {
                oop: [
                    "NOT UPDATE"
                ],
                os: [
                    "NOT UPDATE"
                ],
                ds: [
                    "NOT UPDATE"
                ],
                python: [
                    "NOT UPDATE"
                ]
            }
        };

let isTypingInProgress = false; // Flag to track typing status

function updatePrograms() {
    const semester = document.getElementById("semester").value;
    const subject = document.getElementById("subject").value;
    const programSelect = document.getElementById("program");
    const outputDiv = document.querySelector(".output");

    // Clear previous program options
    programSelect.innerHTML = "<option value=''>--Select Program--</option>";
    outputDiv.style.visibility = "hidden";

    if (semester && subject) {
        const programs = programsData[semester][subject];
        if (programs) {
            // Add program options
            programs.forEach((program, index) => {
                const option = document.createElement("option");
                option.value = index; // Use index as value
                option.textContent = program.split(":")[0]; // Show title only
                programSelect.appendChild(option);
            });

            programSelect.disabled = false;
        } else {
            programSelect.disabled = true;
        }
    } else {
        programSelect.disabled = true;
    }
}

document.getElementById("program").addEventListener("change", function () {
    const selectedProgramIndex = this.value;
    const semester = document.getElementById("semester").value;
    const subject = document.getElementById("subject").value;
    const output = document.getElementById("output");
    const outputDiv = document.querySelector(".output");

    if (semester && subject && selectedProgramIndex !== "") {
        const programList = programsData[semester][subject];
        const program = programList[selectedProgramIndex];

        // Show "Please wait, process is live"
        outputDiv.style.visibility = "visible";
        output.textContent = "Please wait, process is live...";

        // If typing is already in progress, cancel the previous one
        if (isTypingInProgress) {
            output.textContent = "Process is live, try again.";
            return;
        }

        // Set the typing in progress flag
        isTypingInProgress = true;

        // Call typewriter animation function after a small delay
        setTimeout(function () {
            typeWriter(output, program); // Call typewriter animation function
        }, 500); // Add a delay before starting the typing effect
    }
});

function typeWriter(element, text) {
    element.textContent = ""; // Clear the content
    let index = 0;

    function write() {
        if (index < text.length) {
            element.textContent += text.charAt(index);
            index++;
            setTimeout(write, -500); // Faster typing speed (5ms per character)
        }
    }

    write(); // Start the typing animation
}
</script>
</body>
</html>

       
       